import requests
import json
import re
from datetime import datetime, timedelta
import time
from typing import List, Dict, Optional

class VulnerabilityScanner:
    def __init__(self):
        self.cve_api_base = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.nvd_api_base = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'IoT-Security-Scanner/1.0'
        })
        
        # Common IoT vulnerability patterns
        self.iot_vulnerability_keywords = [
            'iot', 'internet of things', 'embedded', 'firmware', 'router', 'camera',
            'smart device', 'connected device', 'wireless', 'mqtt', 'coap', 'upnp',
            'default password', 'authentication bypass', 'remote code execution',
            'buffer overflow', 'command injection', 'path traversal'
        ]
        
        # Severity mapping
        self.severity_mapping = {
            'CRITICAL': 'Critical',
            'HIGH': 'High', 
            'MEDIUM': 'Medium',
            'LOW': 'Low'
        }
    
    def search_vulnerabilities_by_product(self, vendor: str, product: str, version: str = None) -> List[Dict]:
        """Search for vulnerabilities by product information"""
        vulnerabilities = []
        
        try:
            # Build search query
            query_parts = []
            if vendor:
                query_parts.append(f'vendor:{vendor}')
            if product:
                query_parts.append(f'product:{product}')
            if version:
                query_parts.append(f'version:{version}')
            
            # Search in NVD database
            nvd_vulns = self._search_nvd_database(' '.join(query_parts))
            vulnerabilities.extend(nvd_vulns)
            
            # Search for IoT-specific vulnerabilities
            iot_vulns = self._search_iot_vulnerabilities(vendor, product)
            vulnerabilities.extend(iot_vulns)
            
        except Exception as e:
            print(f"Error searching vulnerabilities: {e}")
        
        return vulnerabilities
    
    def _search_nvd_database(self, query: str) -> List[Dict]:
        """Search NVD database for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # NVD API parameters
            params = {
                'keywordSearch': query,
                'resultsPerPage': 50,
                'startIndex': 0
            }
            
            response = self.session.get(self.nvd_api_base, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                if 'vulnerabilities' in data:
                    for vuln_item in data['vulnerabilities']:
                        cve_data = vuln_item.get('cve', {})
                        vuln_info = self._parse_cve_data(cve_data)
                        if vuln_info:
                            vulnerabilities.append(vuln_info)
            
            # Rate limiting - NVD has strict rate limits
            time.sleep(1)
            
        except Exception as e:
            print(f"Error searching NVD database: {e}")
        
        return vulnerabilities
    
    def _parse_cve_data(self, cve_data: Dict) -> Optional[Dict]:
        """Parse CVE data from NVD response"""
        try:
            cve_id = cve_data.get('id', '')
            
            # Get description
            descriptions = cve_data.get('descriptions', [])
            description = ''
            for desc in descriptions:
                if desc.get('lang') == 'en':
                    description = desc.get('value', '')
                    break
            
            # Get severity and CVSS score
            metrics = cve_data.get('metrics', {})
            severity = 'Unknown'
            cvss_score = None
            
            # Try CVSS v3.1 first, then v3.0, then v2.0
            for version in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:
                if version in metrics and metrics[version]:
                    metric = metrics[version][0]
                    if 'cvssData' in metric:
                        cvss_data = metric['cvssData']
                        cvss_score = cvss_data.get('baseScore')
                        severity = cvss_data.get('baseSeverity', 'Unknown')
                        break
            
            # Get published and modified dates
            published_date = None
            updated_date = None
            
            if 'published' in cve_data:
                published_date = datetime.fromisoformat(cve_data['published'].replace('Z', '+00:00'))
            
            if 'lastModified' in cve_data:
                updated_date = datetime.fromisoformat(cve_data['lastModified'].replace('Z', '+00:00'))
            
            # Get references
            references = []
            if 'references' in cve_data:
                for ref in cve_data['references']:
                    references.append(ref.get('url', ''))
            
            # Get affected products
            affected_products = []
            configurations = cve_data.get('configurations', [])
            for config in configurations:
                nodes = config.get('nodes', [])
                for node in nodes:
                    cpe_matches = node.get('cpeMatch', [])
                    for cpe_match in cpe_matches:
                        cpe_name = cpe_match.get('criteria', '')
                        if cpe_name:
                            affected_products.append(cpe_name)
            
            return {
                'cve_id': cve_id,
                'description': description,
                'severity': self.severity_mapping.get(severity.upper(), severity),
                'cvss_score': cvss_score,
                'source': 'NVD',
                'published_date': published_date,
                'updated_date': updated_date,
                'references': references,
                'affected_products': affected_products,
                'recommendation': self._generate_recommendation(description, severity)
            }
            
        except Exception as e:
            print(f"Error parsing CVE data: {e}")
            return None
    
    def _search_iot_vulnerabilities(self, vendor: str, product: str) -> List[Dict]:
        """Search for IoT-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Search for vulnerabilities with IoT-related keywords
            for keyword in self.iot_vulnerability_keywords:
                query = f"{vendor} {product} {keyword}"
                
                params = {
                    'keywordSearch': query,
                    'resultsPerPage': 20,
                    'startIndex': 0
                }
                
                response = self.session.get(self.nvd_api_base, params=params, timeout=10)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    if 'vulnerabilities' in data:
                        for vuln_item in data['vulnerabilities']:
                            cve_data = vuln_item.get('cve', {})
                            vuln_info = self._parse_cve_data(cve_data)
                            if vuln_info and self._is_relevant_to_device(vuln_info, vendor, product):
                                vulnerabilities.append(vuln_info)
                
                # Rate limiting
                time.sleep(0.5)
                
        except Exception as e:
            print(f"Error searching IoT vulnerabilities: {e}")
        
        return vulnerabilities
    
    def _is_relevant_to_device(self, vulnerability: Dict, vendor: str, product: str) -> bool:
        """Check if vulnerability is relevant to the specific device"""
        description = vulnerability.get('description', '').lower()
        affected_products = vulnerability.get('affected_products', [])
        
        # Check if vendor/product mentioned in description
        if vendor and vendor.lower() in description:
            return True
        
        if product and product.lower() in description:
            return True
        
        # Check affected products (CPE names)
        for cpe in affected_products:
            cpe_lower = cpe.lower()
            if vendor and vendor.lower() in cpe_lower:
                return True
            if product and product.lower() in cpe_lower:
                return True
        
        return False
    
    def scan_device_vulnerabilities(self, device_info: Dict) -> List[Dict]:
        """Scan a device for vulnerabilities based on its information"""
        vulnerabilities = []
        
        try:
            vendor = device_info.get('manufacturer', '')
            device_type = device_info.get('device_type', '')
            os_info = device_info.get('os_info', '')
            firmware_version = device_info.get('firmware_version', '')
            open_ports = device_info.get('open_ports', [])
            
            # Search by vendor and device type
            if vendor and device_type:
                vulns = self.search_vulnerabilities_by_product(vendor, device_type, firmware_version)
                vulnerabilities.extend(vulns)
            
            # Search by OS information
            if os_info:
                os_parts = os_info.split()
                if len(os_parts) >= 2:
                    os_vendor = os_parts[0]
                    os_product = ' '.join(os_parts[1:])
                    vulns = self.search_vulnerabilities_by_product(os_vendor, os_product)
                    vulnerabilities.extend(vulns)
            
            # Search by services running on open ports
            for port_info in open_ports:
                service = port_info.get('service', '')
                product = port_info.get('product', '')
                version = port_info.get('version', '')
                
                if product:
                    vulns = self.search_vulnerabilities_by_product('', product, version)
                    vulnerabilities.extend(vulns)
                elif service:
                    vulns = self.search_vulnerabilities_by_product('', service, version)
                    vulnerabilities.extend(vulns)
            
            # Check for common IoT vulnerabilities
            common_vulns = self._check_common_iot_vulnerabilities(device_info)
            vulnerabilities.extend(common_vulns)
            
            # Remove duplicates
            seen_cves = set()
            unique_vulns = []
            for vuln in vulnerabilities:
                cve_id = vuln.get('cve_id', vuln.get('id', ''))
                if cve_id not in seen_cves:
                    seen_cves.add(cve_id)
                    unique_vulns.append(vuln)
            
            vulnerabilities = unique_vulns
            
        except Exception as e:
            print(f"Error scanning device vulnerabilities: {e}")
        
        return vulnerabilities
    
    def _check_common_iot_vulnerabilities(self, device_info: Dict) -> List[Dict]:
        """Check for common IoT vulnerabilities based on device characteristics"""
        vulnerabilities = []
        
        try:
            open_ports = device_info.get('open_ports', [])
            device_type = device_info.get('device_type', '').lower()
            
            # Check for default credentials vulnerability
            if self._has_web_interface(open_ports):
                vulnerabilities.append({
                    'cve_id': None,
                    'description': 'Device may be using default credentials. Many IoT devices ship with default usernames and passwords that are never changed.',
                    'severity': 'High',
                    'cvss_score': 7.5,
                    'source': 'IoT Security Check',
                    'published_date': datetime.utcnow(),
                    'updated_date': datetime.utcnow(),
                    'references': ['https://owasp.org/www-project-iot-security-verification-standard/'],
                    'affected_products': [device_type],
                    'recommendation': 'Change default credentials immediately. Use strong, unique passwords.'
                })
            
            # Check for unencrypted communication
            if self._has_unencrypted_services(open_ports):
                vulnerabilities.append({
                    'cve_id': None,
                    'description': 'Device communicates over unencrypted channels, potentially exposing sensitive data.',
                    'severity': 'Medium',
                    'cvss_score': 5.3,
                    'source': 'IoT Security Check',
                    'published_date': datetime.utcnow(),
                    'updated_date': datetime.utcnow(),
                    'references': ['https://owasp.org/www-project-iot-security-verification-standard/'],
                    'affected_products': [device_type],
                    'recommendation': 'Enable encryption for all communications. Use HTTPS, SSL/TLS, or VPN.'
                })
            
            # Check for unnecessary services
            if len(open_ports) > 5:
                vulnerabilities.append({
                    'cve_id': None,
                    'description': 'Device has many open ports and services, increasing attack surface.',
                    'severity': 'Low',
                    'cvss_score': 3.1,
                    'source': 'IoT Security Check',
                    'published_date': datetime.utcnow(),
                    'updated_date': datetime.utcnow(),
                    'references': ['https://owasp.org/www-project-iot-security-verification-standard/'],
                    'affected_products': [device_type],
                    'recommendation': 'Disable unnecessary services and close unused ports to reduce attack surface.'
                })
            
            # Check for UPnP vulnerabilities
            if any(port['port'] == 1900 for port in open_ports):
                vulnerabilities.append({
                    'cve_id': None,
                    'description': 'UPnP service detected. UPnP can be exploited for various attacks including DDoS amplification.',
                    'severity': 'Medium',
                    'cvss_score': 5.8,
                    'source': 'IoT Security Check',
                    'published_date': datetime.utcnow(),
                    'updated_date': datetime.utcnow(),
                    'references': ['https://www.cisa.gov/news-events/alerts/2013/08/30/upnp-vulnerabilities'],
                    'affected_products': [device_type],
                    'recommendation': 'Disable UPnP if not needed, or ensure it is properly configured and updated.'
                })
            
        except Exception as e:
            print(f"Error checking common IoT vulnerabilities: {e}")
        
        return vulnerabilities
    
    def _has_web_interface(self, open_ports: List[Dict]) -> bool:
        """Check if device has a web interface"""
        web_ports = [80, 443, 8080, 8443, 8888, 9000]
        return any(port['port'] in web_ports for port in open_ports)
    
    def _has_unencrypted_services(self, open_ports: List[Dict]) -> bool:
        """Check if device has unencrypted services"""
        unencrypted_services = ['http', 'telnet', 'ftp', 'smtp']
        return any(port['service'] in unencrypted_services for port in open_ports)
    
    def _generate_recommendation(self, description: str, severity: str) -> str:
        """Generate remediation recommendation based on vulnerability description"""
        description_lower = description.lower()
        
        if 'buffer overflow' in description_lower:
            return 'Update firmware to the latest version. Implement input validation and use memory-safe programming practices.'
        elif 'sql injection' in description_lower:
            return 'Update software to patch SQL injection vulnerabilities. Use parameterized queries and input validation.'
        elif 'cross-site scripting' in description_lower or 'xss' in description_lower:
            return 'Update web interface software. Implement proper input sanitization and output encoding.'
        elif 'authentication' in description_lower and 'bypass' in description_lower:
            return 'Update firmware immediately. Implement strong authentication mechanisms and access controls.'
        elif 'default' in description_lower and ('password' in description_lower or 'credential' in description_lower):
            return 'Change all default credentials immediately. Use strong, unique passwords for all accounts.'
        elif 'remote code execution' in description_lower:
            return 'Apply security patches immediately. This is a critical vulnerability that allows attackers to execute arbitrary code.'
        elif 'denial of service' in description_lower or 'dos' in description_lower:
            return 'Update firmware and implement rate limiting. Monitor for unusual traffic patterns.'
        elif 'information disclosure' in description_lower:
            return 'Update software and review access controls. Ensure sensitive information is properly protected.'
        else:
            return f'Update device firmware to the latest version. Review security configuration and apply vendor security patches.'
    
    def get_zero_day_feeds(self) -> List[Dict]:
        """Get zero-day vulnerability information from various sources"""
        zero_day_vulns = []
        
        try:
            # This would typically involve parsing RSS feeds, threat intelligence APIs, etc.
            # For now, we'll implement a basic structure
            
            # Example sources for zero-day information:
            # - Security blogs and research sites
            # - Threat intelligence feeds
            # - Vendor security advisories
            
            # Placeholder implementation
            recent_date = datetime.utcnow() - timedelta(days=7)
            
            # Search for very recent vulnerabilities that might be zero-days
            params = {
                'pubStartDate': recent_date.strftime('%Y-%m-%dT%H:%M:%S.000'),
                'resultsPerPage': 20
            }
            
            response = self.session.get(self.nvd_api_base, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                if 'vulnerabilities' in data:
                    for vuln_item in data['vulnerabilities']:
                        cve_data = vuln_item.get('cve', {})
                        vuln_info = self._parse_cve_data(cve_data)
                        
                        if vuln_info and self._is_potential_zero_day(vuln_info):
                            vuln_info['source'] = 'Zero-day Feed'
                            zero_day_vulns.append(vuln_info)
            
        except Exception as e:
            print(f"Error getting zero-day feeds: {e}")
        
        return zero_day_vulns
    
    def _is_potential_zero_day(self, vulnerability: Dict) -> bool:
        """Determine if a vulnerability might be a zero-day"""
        # Simple heuristic: very recent publication with high severity
        published_date = vulnerability.get('published_date')
        severity = vulnerability.get('severity', '').lower()
        
        if published_date and severity in ['critical', 'high']:
            days_since_published = (datetime.utcnow() - published_date.replace(tzinfo=None)).days
            return days_since_published <= 3
        
        return False

